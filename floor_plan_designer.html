<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Floor Plan Designer</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }

    body {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    .topbar {
      background-color: #2c3e50;
      color: white;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .logo {
      font-size: 20px;
      font-weight: bold;
    }

    .table-presets {
      display: flex;
      gap: 10px;
    }

    .preset {
      background-color: #3498db;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: grab;
      font-size: 14px;
      user-select: none;
    }

    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .floor-plan {
      flex: 1;
      background-color: #ecf0f1;
      position: relative;
      overflow: auto;
    }

    .grid {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-size: 20px 20px;
      background-image:
        linear-gradient(to right, #ddd 1px, transparent 1px),
        linear-gradient(to bottom, #ddd 1px, transparent 1px);
    }

    .sidebar {
      width: 300px;
      background-color: #f8f9fa;
      border-left: 1px solid #ddd;
      display: flex;
      flex-direction: column;
    }

    .sidebar-section {
      padding: 15px;
      border-bottom: 1px solid #ddd;
    }

    .sidebar-title {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #2c3e50;
    }

    .names-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #namesList {
      width: 100%;
      height: 100%;
      resize: none;
      border: 1px solid #ddd;
      padding: 8px;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .name-item {
      background-color: #3498db;
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      margin-bottom: 5px;
      cursor: grab;
      user-select: none;
      display: inline-block;
      margin-right: 5px;
      margin-bottom: 5px;
    }

    .button {
      background-color: #2c3e50;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 5px;
    }

    .delete-button {
      background-color: #e74c3c;
    }

    .topbar-button {
      background-color: white;
      color: #2c3e50;
      margin-top: 0;
      align-self: center;
    }

    .table {
      position: absolute;
      background-color: #fff;
      border: 2px solid #3498db;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: move;
      user-select: none;
    }

    .table.rectangular {
      display: flex;
      flex-direction: column;
      border-radius: 8px;
    }

    .table.round {
      border-radius: 50%;
    }

    .table > .table-label {
      user-select: none;
      pointer-events: none;
    }

    .table > .chair {
      cursor: default;
    }

    .chair.occupied, .chair.chair.occupied > .name-item {
      cursor: grab !important;
    }

    .chair {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: #95a5a6;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      
      color: white;
      overflow: visible;
      text-overflow: ellipsis;
      white-space: nowrap;
      z-index: 10;
      box-shadow: inset 0 0 2px #2c3e50;
    }

    .chair.occupied {
      background-color: #3498db;
      box-shadow: none;
      cursor: grab;
    }

    .chair .name-item {
      position: absolute;
      top: 50%;           /* tweak to taste */
      left: 50%;
      font-size: 12px;
      padding: 2px;

      transform: translate(-50%, -50%);
      white-space: nowrap;   /* prevent wrapping */
      z-index: 20;           /* above the chair */
    }
    .chair.highlight {
      outline: 2px dashed #2ecc71;
    }
    .chair.loose:not(.occupied) {
      cursor: grab;          /* hand cursor on hover                                     */
      z-index: 30;           /* above any .name-item (those sit at z-index 20)           */
    }
    .name-item.preview {
      opacity: 0.5;
      pointer-events: none;
    }


    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border-radius: 5px;
      width: 300px;
    }

    .modal-field {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    input[type="number"],
    select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .names-display {
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }

    .floor-plan-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
    }

    .status-bar {
      padding: 5px 10px;
      background-color: #f8f9fa;
      border-top: 1px solid #ddd;
      font-size: 12px;
      color: #555;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="logo">Floor Plan Designer</div>
    <div class="table-presets">
      <div class="preset" data-type="rectangular">Rectangular Table</div>
      <div class="preset" data-type="round">Round Table</div>
    </div>
    <button id="addPresetBtn" class="button topbar-button">Add Table</button>
  </div>

  <div class="main-container">
    <div class="floor-plan">
      <div class="floor-plan-container">
        <div class="grid"></div>
        <!-- Tables will be added here -->
      </div>
    </div>

    <div class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">People</div>
        <div class="names-container">
          <textarea id="namesList" placeholder="Enter names (one per line)"></textarea>
          <button id="saveNames" class="button">Save Names</button>
        </div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Seating List</div>
        <div id="namesDisplay" class="names-display"></div>
      </div>

      <div class="sidebar-section">
        <button id="clearAll" class="button delete-button">Clear Floor Plan</button>
      </div>
    </div>
  </div>

  <div class="status-bar">Ready</div>

  <!-- Table preset-creation modal -->
  <div id="presetModal" class="modal">
    <div class="modal-content">
      <h3>Create Table Preset</h3>
      <div class="modal-field">
        <label for="presetName">Preset Name:</label>
        <input type="text" id="presetName" placeholder="e.g. 'Large Round'">
      </div>
      <div class="modal-field">
        <label for="presetType">Type:</label>
        <select id="presetType">
          <option value="rectangular">Rectangular</option>
          <option value="round">Round</option>
        </select>
      </div>

      <!-- reuse your existing dimension fields, wrapped for preset use -->
      <div id="presetRectFields" class="modal-field">
        <label>Width (cm):</label>
        <input type="number" id="presetWidth" min="60" max="300" value="120">
        <label>Length (cm):</label>
        <input type="number" id="presetLength" min="60" max="300" value="220">
        <label>Chairs on Width:</label>
        <input type="number" id="presetChairsOnWidth" min="0" max="10" value="0">
        <label>Chairs on Length:</label>
        <input type="number" id="presetChairsOnLength" min="0" max="10" value="4">
      </div>
      <div id="presetRoundFields" class="modal-field" style="display:none">
        <label>Diameter (cm):</label>
        <input type="number" id="presetDiameter" min="60" max="300" value="120">
        <label>Number of Chairs:</label>
        <input type="number" id="presetChairCount" min="0" max="12" value="6">
      </div>

      <div class="modal-buttons">
        <button id="cancelPreset" class="button delete-button">Cancel</button>
        <button id="createPreset" class="button">Save Preset</button>
      </div>
    </div>
  </div>


  <script>
    // Global variables
    let tables = [];
    let nextTableId = 1;
    let draggedItemType = null;
    let draggedChair = null;
    let draggedTable = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let people = [];
    let draggedSourceTag = null;   // the <div class="name‑item"> we’re dragging
    let selectedPersonName = null;   // convenience string copy of its text
    const snapDistance = 40;      // pixels
    let previewClone = null;
    let lastPreviewChair = null;
    let draggedFromChair = null;
    let dragDidDrop = false;
    let draggedStandaloneChair = null;
    let presets = [
      {           // the fixed chair preset
        name: 'Empty Chair',
        type: 'chair',          // a special type we’ll handle below
        nonRemovable: true      // flag so we can block deleting
      },

      // the two table presets you already had
      { name: 'Rectangular Table', type: 'rectangular',
        config: { width:120, length:220, chairsOnWidth:0, chairsOnLength:4 } },
      { name: 'Round Table',       type: 'round',
        config: { diameter:120, chairCount:6 } }
    ];


    // DOM elements
    const presetsContainer = document.querySelector('.table-presets');
    const floorPlan = document.querySelector('.floor-plan-container');
    const tablePresets = document.querySelectorAll('.preset');
    const namesList = document.getElementById('namesList');
    const saveNamesBtn = document.getElementById('saveNames');
    const namesDisplay = document.getElementById('namesDisplay');
    const clearAllBtn = document.getElementById('clearAll');
    const tableModal = document.getElementById('tableModal');
    const createTableBtn = document.getElementById('createTable');
    const cancelTableBtn = document.getElementById('cancelTable');
    const rectangularFields = document.getElementById('rectangularFields');
    const roundFields = document.getElementById('roundFields');
    const statusBar = document.querySelector('.status-bar');
    const sidebar = document.querySelector('.sidebar');

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initializeEventListeners();
      renderPresets();
    });

    function initializeEventListeners() {
      // Table preset drag
      tablePresets.forEach(preset => {
        preset.addEventListener('dragstart', handlePresetDragStart);
        preset.setAttribute('draggable', 'true');
      });

      // Floor plan drop area
      floorPlan.addEventListener('dragover', handleDragOver);
      floorPlan.addEventListener('drop', handleDrop);

      // Save names button
      saveNamesBtn.addEventListener('click', saveNames);

      // Table modal buttons
      if (createTableBtn)  createTableBtn.addEventListener('click', createTableFromModal);
      if (cancelTableBtn)  cancelTableBtn.addEventListener('click', closeTableModal);

      // Clear all button
      clearAllBtn.addEventListener('click', clearAction);
      updateClearButton();

      // Mouse events for floor plan
      floorPlan.addEventListener('mousedown', handleFloorPlanMouseDown);
      document.addEventListener('mousemove', handleDocumentMouseMove);
      document.addEventListener('mouseup', handleDocumentMouseUp);

      // ─── allow dragging people back into the list ───
      [namesDisplay, sidebar].forEach(el => {
        el.addEventListener('dragover', e => {
          if (draggedSourceTag) e.preventDefault();      // show valid cursor
        });

        el.addEventListener('drop', e => {
          e.preventDefault();
          dropNameIntoList();                            // do the move
        });
      });

      function dropNameIntoList() {
        if (!draggedSourceTag) return;

        // if the tag came from a chair, empty that chair first
        if (draggedFromChair) {
          draggedFromChair.classList.remove('occupied');
          draggedFromChair.innerHTML = '';
        }

        namesDisplay.appendChild(draggedSourceTag);
        updateClearButton();
        dragDidDrop = true;
        draggedSourceTag = null;
        draggedFromChair = null;
      }


      // show/hide the proper fields in the preset modal
      document.getElementById('presetType').addEventListener('change', e => {
        if (e.target.value === 'rectangular') {
          document.getElementById('presetRectFields').style.display = 'block';
          document.getElementById('presetRoundFields').style.display = 'none';
        } else {
          document.getElementById('presetRectFields').style.display = 'none';
          document.getElementById('presetRoundFields').style.display = 'block';
        }
      });

      // Open the preset modal
      document.getElementById('addPresetBtn').addEventListener('click', () => {
        document.getElementById('presetModal').style.display = 'block';
      });

      // Cancel
      document.getElementById('cancelPreset').addEventListener('click', () => {
        document.getElementById('presetModal').style.display = 'none';
      });

      // Open the preset modal when you click "Add Table"
      document.getElementById('addPresetBtn').addEventListener('click', () => {
        document.getElementById('presetModal').style.display = 'block';
      });

      // Cancel button inside the preset modal
      document.getElementById('cancelPreset').addEventListener('click', () => {
        document.getElementById('presetModal').style.display = 'none';
      });

      // Save the new preset
      document.getElementById('createPreset').addEventListener('click', () => {
        const name = document.getElementById('presetName').value.trim();
        const type = document.getElementById('presetType').value;
        if (!name) return alert('Please give your preset a name.');

        let config;
        if (type === 'rectangular') {
          config = {
            width: +document.getElementById('presetWidth').value,
            length: +document.getElementById('presetLength').value,
            chairsOnWidth: +document.getElementById('presetChairsOnWidth').value,
            chairsOnLength: +document.getElementById('presetChairsOnLength').value
          };
        } else {
          config = {
            diameter: +document.getElementById('presetDiameter').value,
            chairCount: +document.getElementById('presetChairCount').value
          };
        }

        presets.push({ name, type, config });
        renderPresets();
        document.getElementById('presetModal').style.display = 'none';
      });

      // right-click anywhere on the floor-plan ----------------------------------
      floorPlan.addEventListener('contextmenu', e => {
        // find the nearest chair or table they clicked
        const chair = e.target.closest('.chair');
        const table = e.target.closest('.table');
        const loose  = e.target.closest('.chair.loose');

        // 1) if it’s an attached chair, clear it and stop
        if (chair && !chair.classList.contains('loose')) {
          e.preventDefault();
          if (chair.classList.contains('occupied')) {
            moveOccupantBackToList(chair);
            updateStatus('Chair cleared');
          }
          return;
        }

        // 2) otherwise if it’s a loose chair or a whole table, try delete
        const target = loose || table;
        if (target) {
          e.preventDefault();
          tryDeleteElement(target);
        }
      });

    }

    function renderPresets() {
      presetsContainer.innerHTML = '';
      presets.forEach((p, i) => {
        const btn = document.createElement('div');
        btn.className = 'preset';
        btn.textContent = p.name;
        btn.draggable = true;
        btn.dataset.index = i;

        // normal dragstart: carry the config
        btn.addEventListener('dragstart', e => {
          if (p.type === 'chair') {
            e.dataTransfer.setData('text/plain', 'chair');        // simple flag
          } else {
            e.dataTransfer.setData('application/json',
                                  JSON.stringify(p.config));     // table data
          }
          draggedItemType = p.type;
          e.dataTransfer.effectAllowed = 'copyMove';
        });

        // right-click / ctrl+click to remove
        if (!p.nonRemovable) {
          btn.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (confirm(`Delete preset "${p.name}"?`)) {
              presets.splice(i, 1);
              renderPresets();
            }
          });

          btn.addEventListener('click', e => {
            if (e.ctrlKey) {
              e.preventDefault();
              if (confirm(`Delete preset "${p.name}"?`)) {
                presets.splice(i, 1);
                renderPresets();
              }
            }
          });
        }

        presetsContainer.appendChild(btn);
      });
    }


    // Drag and drop handlers
    function handlePresetDragStart(e) {
      draggedItemType = e.target.getAttribute('data-type');
      e.dataTransfer.setData('text/plain', draggedItemType);
      e.dataTransfer.effectAllowed = 'copyMove';
    }

    function handleDragOver(e) {
      e.preventDefault();  // allow drop

      // Only do snap-preview if we're dragging a person
      if (draggedSourceTag) {
        const x = e.clientX, y = e.clientY;
        // find nearest chair within snapDistance
        let nearest = null, minD = snapDistance;
        document.querySelectorAll('.chair').forEach(chair => {
          const r = chair.getBoundingClientRect();
          const cx = r.left + r.width/2, cy = r.top + r.height/2;
          const d = Math.hypot(cx - x, cy - y);
          if (d < minD) {
            minD = d; nearest = chair;
          }
        });

        // if we snapped to a new chair, update preview
        if (nearest !== lastPreviewChair) {
          // clear old
          if (lastPreviewChair) {
            lastPreviewChair.classList.remove('highlight');
            if (previewClone) lastPreviewChair.removeChild(previewClone);
          }
          lastPreviewChair = nearest;

          if (nearest) {
            // clone and show
            previewClone = draggedSourceTag.cloneNode(true);
            previewClone.classList.add('preview');
            nearest.appendChild(previewClone);
            nearest.classList.add('highlight');
          } else {
            previewClone = null;
          }
        }

        // show move cursor
        e.dataTransfer.dropEffect = 'move';
        return;
      }

      // fallback: treat as table-drop
      const allowed = e.dataTransfer.effectAllowed;
      e.dataTransfer.dropEffect = allowed.includes('copy') ? 'copy' : 'copyMove';
    }


    function handleDrop(e) {
      e.preventDefault();

      // clear preview
      if (lastPreviewChair) {
        lastPreviewChair.classList.remove('highlight');
        if (previewClone) lastPreviewChair.removeChild(previewClone);
        previewClone = null;
        lastPreviewChair = null;
      }

      // —— 1) if we have a draggedSourceTag, it must be a person label ——
      if (draggedSourceTag) {
        const chair = findChairAtPosition(e.clientX, e.clientY);
        if (!chair) {
          updateStatus('Drop on a chair, please');
          return;
        }

        // if occupied, kick the old occupant out
        if (chair.classList.contains('occupied')) {
          moveOccupantBackToList(chair);
        }

        // tidy up its old seat/list
        const from = draggedSourceTag.parentElement;
        if (from.classList.contains('chair')) {
          from.classList.remove('occupied');
          from.innerHTML = '';
        }
        // if it was in the sidebar list, appendChild will remove it automatically

        // **drop the real element** onto the chair
        chair.appendChild(draggedSourceTag);
        chair.classList.add('occupied');

        dragDidDrop = true;

        updateStatus(`Assigned ${draggedSourceTag.textContent} to a seat`);
        updateClearButton();

        // reset
        draggedSourceTag = null;
        return;
      }

      // 2-A)  single empty chair dropped from the preset bar ------------
      if (e.dataTransfer.getData('text/plain') === 'chair') {
        const chair = createChair();
        floorPlan.appendChild(chair);
        makeLooseChairDraggable(chair);

        // position it where the cursor is
        const fpRect = floorPlan.getBoundingClientRect();
        chair.style.left = (e.clientX - fpRect.left - 10) + 'px';   // 10 = half width
        chair.style.top  = (e.clientY - fpRect.top  - 10) + 'px';

        return;    // stop – nothing else to do
      }

      // —— 2) otherwise it’s a table preset —— 
      const cfgJson = e.dataTransfer.getData('application/json');
      if (cfgJson) {
        const cfg  = JSON.parse(cfgJson);              // the dimensions/chair data
        const type = cfg.diameter ? 'round' : 'rectangular';

        // Build the full table-config object expected by createTable()
        const tableConfig = {
          ...cfg,
          type,            // “round” or “rectangular”
          id:           nextTableId,
          tableNumber:  nextTableId
        };

        createTable(tableConfig, e.clientX, e.clientY); // 🠒 instantly place table
        nextTableId++;                                   // keep IDs unique
        return;                                          // important – stop here
      }
    }

    function makeLooseChairDraggable(chair) {
      chair.classList.add('loose');   // enables the CSS you just added
      chair.style.zIndex = '30';      // keeps it above labels even while dragging
    }


    /* -----------------------------------------------------------------
    * Helper: build <div class="name-item">… that is draggable
    * -----------------------------------------------------------------*/
    function createPersonTag(name) {
      const tag = document.createElement('div');
      tag.className = 'name-item';
      tag.textContent = name;
      tag.setAttribute('draggable', 'true');

      tag.addEventListener('dragstart', e => {
        draggedSourceTag = tag;
        // remember where we came from
        const parent = tag.parentElement;
        draggedFromChair = parent.classList.contains('chair') ? parent : null;
        dragDidDrop = false;

        selectedPersonName = name;
        e.dataTransfer.setData('text/plain', name);
        e.dataTransfer.effectAllowed = 'move';
      });

      tag.addEventListener('dragend', () => {
        // if we never dropped anywhere valid, snap back to original chair
        if (!dragDidDrop && draggedFromChair) {
          draggedFromChair.appendChild(tag);
          draggedFromChair.classList.add('occupied');
        }
        // clean up
        draggedSourceTag = null;
        draggedFromChair = null;
        dragDidDrop = false;
      });

      tag.addEventListener('click', e => {
        if (e.ctrlKey && tag.parentElement.classList.contains('chair')) {
          moveOccupantBackToList(tag.parentElement);
        }
      });

      return tag;
    }

    // Mouse interaction handlers
    function handleFloorPlanMouseDown(e) {
      /* -------------------------------------------------------------
      * 1.  Ctrl-click  → delete a table or a loose chair  (runs first)
      * ------------------------------------------------------------*/
      if (e.ctrlKey) {
        const el = e.target;
        const target =
            el.classList.contains('table')               ? el :
            (el.classList.contains('chair') &&
             el.classList.contains('loose'))             ? el : null;
      
        if (target) {
          tryDeleteElement(target);
          e.preventDefault();     // stop drag / selection, etc.
          return;                 // nothing else for this click
        }
      }

      /* -------------------------------------------------------------
      * 2.  start dragging a table
      * ------------------------------------------------------------*/
      const tableEl   = e.target.closest('.table');
      const clickedChair = e.target.closest('.chair');
      if (tableEl && !clickedChair) {
        draggedTable = tableEl;
        const rect = tableEl.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        tableEl.style.zIndex = '50';
        e.preventDefault();
        return;
      }

      /* -------------------------------------------------------------
      * 3.  start dragging a loose empty chair
      * ------------------------------------------------------------*/
      if (e.target.classList.contains('chair') &&
          !e.target.classList.contains('occupied') &&
          e.target.parentElement === floorPlan) {
        draggedStandaloneChair = e.target;
        const r = draggedStandaloneChair.getBoundingClientRect();
        dragOffsetX = e.clientX - r.left;
        dragOffsetY = e.clientY - r.top;
        draggedStandaloneChair.style.zIndex = '60';
        e.preventDefault();
        return;
      }

      /* -------------------------------------------------------------
      * 4.  (unchanged) Ctrl-click on an *occupied* chair → clear it
      * ------------------------------------------------------------*/
      const chair = e.target.closest('.chair');
      if (chair && chair.classList.contains('occupied') && e.ctrlKey) {
        moveOccupantBackToList(chair);
        updateStatus('Chair cleared');
        e.preventDefault();
      }
    }


    function handleDocumentMouseMove(e) {
      if (draggedStandaloneChair) {
        const fpRect = floorPlan.getBoundingClientRect();
        const x = e.clientX - dragOffsetX - fpRect.left;
        const y = e.clientY - dragOffsetY - fpRect.top;

        // keep inside the floor-plan viewport
        draggedStandaloneChair.style.left =
          Math.max(0, Math.min(fpRect.width  - 20, x)) + 'px';
        draggedStandaloneChair.style.top  =
          Math.max(0, Math.min(fpRect.height - 20, y)) + 'px';

        return;               // don’t also run the table code
      }
      if (draggedTable) {
        // Move table
        const x = e.clientX - dragOffsetX;
        const y = e.clientY - dragOffsetY;

        // Get floor plan bounds
        const floorPlanRect = floorPlan.getBoundingClientRect();

        // Position table with constraints
        draggedTable.style.left = Math.max(0, Math.min(floorPlanRect.width - draggedTable.offsetWidth, x - floorPlanRect.left)) + 'px';
        draggedTable.style.top = Math.max(0, Math.min(floorPlanRect.height - draggedTable.offsetHeight, y - floorPlanRect.top)) + 'px';

        // Update chairs positions
        updateChairPositions(draggedTable);
      }
    }

    function handleDocumentMouseUp(e) {
      if (draggedTable) {
        // End table drag
        draggedTable.style.zIndex = '';
        draggedTable = null;
      }
    
      if (draggedStandaloneChair) {
        draggedStandaloneChair.style.zIndex = '';
        draggedStandaloneChair = null;
      }

      // Clear any highlighted chairs
      document.querySelectorAll('.chair.highlight').forEach(chair => {
        chair.classList.remove('highlight');
      });
    }

    // Table creation
    function showTableModal(type, x, y) {
      // Store position for later table creation
      tableModal.dataset.posX = x;
      tableModal.dataset.posY = y;
      tableModal.dataset.type = type;

      // Show appropriate fields
      if (type === 'rectangular') {
        rectangularFields.style.display = 'block';
        roundFields.style.display = 'none';
      } else {
        rectangularFields.style.display = 'none';
        roundFields.style.display = 'block';
      }

      // Set default table number
      document.getElementById('tableNumber').value = nextTableId;

      // Show modal
      tableModal.style.display = 'block';
    }

    function closeTableModal() {
      tableModal.style.display = 'none';
    }

    function createTableFromModal() {
      const type = tableModal.dataset.type;
      const posX = parseInt(tableModal.dataset.posX);
      const posY = parseInt(tableModal.dataset.posY);

      let tableConfig = {
        id: nextTableId,
        type: type,
        tableNumber: parseInt(document.getElementById('tableNumber').value)
      };

      if (type === 'rectangular') {
        tableConfig.width = parseInt(document.getElementById('tableWidth').value);
        tableConfig.length = parseInt(document.getElementById('tableLength').value);
        tableConfig.chairsOnWidth = parseInt(document.getElementById('chairsOnWidth').value);
        tableConfig.chairsOnLength = parseInt(document.getElementById('chairsOnLength').value);
      } else {
        tableConfig.diameter = parseInt(document.getElementById('tableDiameter').value);
        tableConfig.chairCount = parseInt(document.getElementById('chairCount').value);
      }

      createTable(tableConfig, posX, posY);
      closeTableModal();

      // Increment table ID for next table
      nextTableId++;
    }

    function createTable(config, posX, posY) {
      const table = document.createElement('div');
      table.className = `table ${config.type}`;
      table.dataset.id = config.id;
      table.dataset.type = config.type;

      // Calculate table size (pixels)
      const scaleFactor = 0.5; // cm to pixels scaling

      if (config.type === 'rectangular') {
        const width = config.width * scaleFactor;
        const length = config.length * scaleFactor;

        table.style.width = width + 'px';
        table.style.height = length + 'px';

        // Add table number label
        const label = document.createElement('div');
        label.textContent = `${config.tableNumber}`;
        table.appendChild(label);

        // Calculate position (center on cursor)
        const floorPlanRect = floorPlan.getBoundingClientRect();
        table.style.left = (posX - floorPlanRect.left - width / 2) + 'px';
        table.style.top = (posY - floorPlanRect.top - length / 2) + 'px';

        // Create chairs
        createChairsForRectangularTable(table, config);
      } else {
        const diameter = config.diameter * scaleFactor;

        table.style.width = diameter + 'px';
        table.style.height = diameter + 'px';

        // Add table number label
        const label = document.createElement('div');
        label.textContent = `${config.tableNumber}`;
        label.classList.add('table-label');
        label.style.pointerEvents = 'none'; 
        table.appendChild(label);

        // Calculate position (center on cursor)
        const floorPlanRect = floorPlan.getBoundingClientRect();
        table.style.left = (posX - floorPlanRect.left - diameter / 2) + 'px';
        table.style.top = (posY - floorPlanRect.top - diameter / 2) + 'px';

        // Create chairs
        createChairsForRoundTable(table, config);
      }

      // Add to floor plan
      floorPlan.appendChild(table);

      // Add to tables array
      tables.push({
        element: table,
        config: config
      });

      updateStatus(`Created ${config.type} table (Table ${config.tableNumber})`);
    }

    function createChairsForRectangularTable(table, config) {
      const chairSize = 20; // pixels
      const chairOffset = 15; // distance from table edge

      // Get table dimensions
      const width = parseInt(table.style.width);
      const height = parseInt(table.style.height);

      // Add chairs on width sides
      for (let i = 0; i < config.chairsOnWidth; i++) {
        // Top side
        if (config.chairsOnWidth > 0) {
          const spacing = width / (config.chairsOnWidth + 1);
          const chair = createChair();
          chair.style.left = ((i + 1) * spacing - chairSize / 2) + 'px';
          chair.style.top = (-chairOffset - chairSize / 2) + 'px';
          table.appendChild(chair);
        }

        // Bottom side
        if (config.chairsOnWidth > 0) {
          const spacing = width / (config.chairsOnWidth + 1);
          const chair = createChair();
          chair.style.left = ((i + 1) * spacing - chairSize / 2) + 'px';
          chair.style.top = (height + chairOffset - chairSize / 2) + 'px';
          table.appendChild(chair);
        }
      }

      // Add chairs on length sides
      for (let i = 0; i < config.chairsOnLength; i++) {
        // Left side
        if (config.chairsOnLength > 0) {
          const spacing = height / (config.chairsOnLength + 1);
          const chair = createChair();
          chair.style.left = (-chairOffset - chairSize / 2) + 'px';
          chair.style.top = ((i + 1) * spacing - chairSize / 2) + 'px';
          table.appendChild(chair);
        }

        // Right side
        if (config.chairsOnLength > 0) {
          const spacing = height / (config.chairsOnLength + 1);
          const chair = createChair();
          chair.style.left = (width + chairOffset - chairSize / 2) + 'px';
          chair.style.top = ((i + 1) * spacing - chairSize / 2) + 'px';
          table.appendChild(chair);
        }
      }
    }

    function createChairsForRoundTable(table, config) {
      const chairSize = 20; // pixels
      const diameter = parseInt(table.style.width);
      const radius = diameter / 2;
      const chairOffset = 15; // distance from table edge

      // Create chairs around the circle
      for (let i = 0; i < config.chairCount; i++) {
        const angle = (i * 2 * Math.PI) / config.chairCount;
        const chair = createChair();

        // Calculate position
        const totalRadius = radius + chairOffset;
        const x = totalRadius * Math.cos(angle) + radius - chairSize / 2;
        const y = totalRadius * Math.sin(angle) + radius - chairSize / 2;

        chair.style.left = x + 'px';
        chair.style.top = y + 'px';
        table.appendChild(chair);
      }
    }

    /* -----------------------------------------------------------------
    * Build a seat (<div class="chair">).  Each seat is a drop target.
    * -----------------------------------------------------------------*/
    function createChair() {
      const chair = document.createElement('div');
      chair.className = 'chair';
      return chair;
    }


    function moveOccupantBackToList(chair) {
      const occupant = chair.querySelector('.name-item');
      if (occupant) {
        namesDisplay.appendChild(occupant);    // move, don’t clone
      }
      chair.innerHTML = '';
      chair.classList.remove('occupied');
      updateClearButton();
    }


    function updateChairPositions(table) {
      // The chairs are child elements of the table, so they move with it
    }

    // Person management
    function saveNames() {
      // 1) parse the textarea into your new list
      const newPeople = namesList.value
        .split('\n')
        .map(n => n.trim())
        .filter(n => n);

      // 2) eject any occupant whose name isn’t in newPeople
      document.querySelectorAll('.chair.occupied').forEach(chair => {
        const occupant = chair.querySelector('.name-item');
        if (occupant && !newPeople.includes(occupant.textContent)) {
          // move them back or just clear the chair:
          namesDisplay.appendChild(occupant);
          chair.innerHTML = '';
          chair.classList.remove('occupied');
        }
      });

      // 3) commit the new people array
      people = newPeople;
      namesList.value = people.join('\n');

      // 4) rebuild the sidebar with only _unseated_ names
      namesDisplay.innerHTML = '';
      // collect the names already on chairs
      const seated = new Set(
        Array.from(document.querySelectorAll('.chair.occupied .name-item'))
            .map(el => el.textContent)
      );
      // for every name in people, if they're not seated, show them in the list
      people.forEach(name => {
        if (!seated.has(name)) {
          namesDisplay.appendChild(createPersonTag(name));
        }
      });

      updateStatus(`Saved ${people.length} people`);
      updateClearButton();
    }

    function updateNamesDisplay() {
      namesDisplay.innerHTML = '';
      people.forEach(name => namesDisplay.appendChild(createPersonTag(name)));
    }

    function findChairAtPosition(x, y) {
      let best = null, bestDist = Infinity;

      document.querySelectorAll('.chair').forEach(chair => {
        const r = chair.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        const d = Math.hypot(cx - x, cy - y);

        // use the same snapDistance as preview
        if (d < snapDistance && d < bestDist) {
          bestDist = d;
          best = chair;
        }
      });

      return best;
    }



    function assignPersonToChair(name, chair) {
      // wipe any previous occupant
      chair.innerHTML = '';
      chair.classList.add('occupied');

      // Drop a fresh tag inside the chair (it stays draggable)
      const tag = createPersonTag(name);
      tag.style.cursor = 'grab';
      // Prevent the small tag from eating pointer events meant for the chair
      chair.appendChild(tag);

      updateStatus(`Assigned ${name} to a seat`);
    }

    // Utilities
    function clearFloorPlan() {
      if (confirm('Are you sure you want to clear the floor plan?')) {
        // Remove all tables
        tables.forEach(table => {
          table.element.remove();
        });
        tables = [];
        updateStatus('Floor plan cleared');
      }
    }

    function clearAction() {
      const occupiedChairs = document.querySelectorAll('.chair.occupied');
      if (occupiedChairs.length > 0) {
        // If anyone’s seated → empty only the seats
        if (confirm('Remove everyone from their seats?')) {
          occupiedChairs.forEach(moveOccupantBackToList);
          updateStatus('All seats emptied');
        }
      } else {
        // Otherwise → clear all tables
        if (confirm('Are you sure you want to clear the floor plan?')) {
          tables.forEach(t => t.element.remove());
          tables = [];
          updateStatus('Floor plan cleared');
        }
      }
      updateClearButton();
    }

    function updateClearButton() {
      const occupiedCount = document.querySelectorAll('.chair.occupied').length;
      if (occupiedCount > 0) {
        clearAllBtn.textContent = 'Empty Seats';
      } else {
        clearAllBtn.textContent = 'Clear Floor Plan';
      }
    }

    /* ---------------------------------------------------------------
    * Delete a table or loose-chair.  If it contains a <div.name-item>
    * we ➊ ask for confirmation, then ➋ move those tags back to
    * #namesDisplay so the names aren’t lost.
    * --------------------------------------------------------------*/
    function tryDeleteElement(el) {
      // 1) does it have people on it?
      const occupiedTags = el.querySelectorAll('.name-item');
      if (occupiedTags.length &&
          !confirm('This item has seated people – delete anyway?')) {
        return;     // user backed out
      }

      // 2) move any occupants back to the list
      occupiedTags.forEach(tag => namesDisplay.appendChild(tag));

      // 3) keep the tables[] array clean
      if (el.classList.contains('table')) {
        tables = tables.filter(t => t.element !== el);
      }

      // 4) remove from the DOM
      el.remove();
      updateClearButton();
      updateStatus('Item deleted');
    }


    function updateStatus(message) {
      statusBar.textContent = message;
    }
  </script>
</body>

</html>