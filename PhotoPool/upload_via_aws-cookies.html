<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Wedding Photo Upload</title>
<style>
body{font-family:system-ui;margin:0;background:#fafafa;color:#222}
header{padding:1rem}
#tabs{display:flex;gap:.5rem;margin-bottom:1rem}
.tab-header{padding:.4rem 1rem;border:1px solid #ccc;border-bottom:none;
            background:#eee;cursor:pointer;border-radius:6px 6px 0 0}
.tab-header.active{background:#fff;font-weight:600}
.tab-panel{display:none}
.tab-panel.active{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));
                  gap:.75rem;padding:0 1rem 2rem}
figure{margin:0;position:relative}
img,video{width:100%;aspect-ratio:1/1;object-fit:cover;border-radius:8px}
.del{position:absolute;top:4px;right:4px;border-radius:4px;font-size:.75rem;cursor:pointer}
.video-icon {
  position: absolute;
  top: 4px;
  left: 4px;
  width: 24px;      /* scale down the 48Ã—48 PNG */
  height: 24px;
  pointer-events: none;
  z-index: 2;
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 3px;
}

#overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;
         background:rgba(0,0,0,.8);z-index:10000}
#overlay.visible{display:flex}
#overlay img,#overlay video{max-width:90vw;max-height:min(87vh, calc(100% - 30px));  
  position: absolute; top:49.5%; transform:translateY(-50%);
  
  width: auto;
  height: auto;
  aspect-ratio: auto;
  object-fit: contain;border-radius:8px}
#timestamp{position:absolute;top:1rem;left:50%;transform:translateX(-50%);
           color:#fff;font-size:1.1rem;font-weight:600; text-align: center;z-index:10001; text-shadow: 1px 1px 5px black;}
#downloadBtn{position:fixed;bottom:0.75rem;left:50%;transform:translateX(-50%);
             padding:.6rem 1.2rem;background:#fff;border:1px solid #444;border-radius:6px;
             cursor:pointer;font-weight:600;z-index:10001}
#addBtn{margin:0 1rem 0rem;padding:.5rem 1rem;font-size:1rem; border-radius: 8px;}
</style>
</head>
<body>
<header>
  <button id="addBtn">Add photos / videos</button>
  <input id="filePicker" type="file" multiple accept="image/*,video/*" hidden>
</header>

<div id="tabs">
  <div id="tabAll"  class="tab-header active">All Uploads</div>
  <div id="tabMine" class="tab-header">My Uploads</div>
</div>
<section id="panelAll"  class="tab-panel active"></section>
<section id="panelMine" class="tab-panel"></section>
<footer id="loadMoreContainer" style="text-align:center; padding:1rem;">
  <button id="loadMoreBtn" style="padding:.5rem 1rem; font-size:1rem;">Load more</button>
</footer>

<div id="overlay">
  <div id="timestamp"></div>
</div>
<button id="downloadBtn" style="display:none">Download</button>

<script type="module">
// â”€â”€ AWS config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const REGION  = "us-west-2";
const ID_POOL = "us-west-2:8e34a4e5-741b-402e-9bfb-eeb90b5643e3";
const BUCKET  = "weddingphotos-2025";

import { parse } from
  "https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.esm.mjs"; 
import {
  S3Client, ListObjectsV2Command, PutObjectCommand, HeadObjectCommand, DeleteObjectCommand
} from "https://esm.sh/@aws-sdk/client-s3@3.569.0?bundle&target=es2020&conditions=browser";
import { fromCognitoIdentityPool }
  from "https://esm.sh/@aws-sdk/credential-provider-cognito-identity@3.569.0?bundle&target=es2020&conditions=browser";

const s3 = new S3Client({
  region: REGION,
  credentials: fromCognitoIdentityPool({ identityPoolId: ID_POOL, clientConfig:{region:REGION}})
});

// â”€â”€ use localStorage instead of cookies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getUploads(){
  try { return JSON.parse(localStorage.getItem("myUploads") || "[]"); }
  catch { return []; }
}
function saveUploads(arr){
  localStorage.setItem("myUploads", JSON.stringify(arr));
}
function remember(key){
  const arr = getUploads();
  if (!arr.includes(key)) {
    arr.push(key);
    saveUploads(arr);
  }
}
function mine(){
  return new Set(getUploads());
}

// â”€â”€ DOM refs & tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const picker   = document.getElementById('filePicker');
const addBtn   = document.getElementById('addBtn');
const panelAll = document.getElementById('panelAll');
const panelMine= document.getElementById('panelMine');
const overlay  = document.getElementById('overlay');
const tsLabel  = document.getElementById('timestamp');
const dlBtn    = document.getElementById('downloadBtn');

document.getElementById('tabAll').onclick  = ()=>switchTab(true);
document.getElementById('tabMine').onclick = ()=>switchTab(false);
function switchTab(showAll){
  document.getElementById('tabAll').classList.toggle('active',  showAll);
  document.getElementById('tabMine').classList.toggle('active', !showAll);
  panelAll.classList.toggle('active',  showAll);
  panelMine.classList.toggle('active', !showAll);
}

// â”€â”€ upload flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
addBtn.onclick = ()=>picker.click();
picker.onchange = async ev => {
  const newKeys = [];
  for (const file of ev.target.files) {
    const key = `${Date.now()}_${file.name}`;
    await s3.send(new PutObjectCommand({
      Bucket:      BUCKET,
      Key:         key,
      Body:        file,
      ContentType: file.type
    }));
    remember(key);
    newKeys.push(key);
  }
  picker.value = "";
  // only append the ones we just added
  await appendNew(newKeys);
};



// â”€â”€ overlay & download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentSrc = "", currentName = "";
function openOverlay(src,isVideo,tsReadable,fileName){
  currentSrc = src; currentName = fileName;
  overlay.innerHTML = "";
  tsLabel.textContent = `${tsReadable}`;
  overlay.appendChild(tsLabel);
  overlay.appendChild(isVideo
    ? Object.assign(document.createElement('video'), {src,controls:true})
    : Object.assign(document.createElement('img'),   {src})
  );
  overlay.classList.add('visible');
  dlBtn.style.display = 'block';
}
function closeOverlay(){
  /* â‘  stop video if one is present */
  const vid = overlay.querySelector('video');
  if (vid) {
    vid.pause();
    vid.currentTime = 0;
  }

  overlay.classList.remove('visible');
  dlBtn.style.display = 'none';
}
overlay.onclick = e=>{ if(e.target===overlay) closeOverlay(); };
window.addEventListener('keydown', e=>{ if(e.key==='Escape') closeOverlay(); });

dlBtn.onclick = async ()=>{
  dlBtn.disabled = true;
  try {
    const resp = await fetch(currentSrc);
    const blob = await resp.blob();
    const url  = URL.createObjectURL(blob);
    const a    = Object.assign(document.createElement('a'), {
      href: url, download: currentName
    });
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  } finally { dlBtn.disabled = false; }
};

// â”€â”€ gallery render (newestâ†’oldest) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ lazy-load observer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const io = new IntersectionObserver(entries => {
  for (let e of entries) {
    if (e.isIntersecting) {
      const el = e.target;
      el.src = el.dataset.src;
      if (el.tagName === 'VIDEO') el.load();
      io.unobserve(el);
    }
  }
}, { rootMargin: '200px' });

// â”€â”€ paging variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const batchSize = 20;
let loadedCount = batchSize;
const loadMoreBtn = document.getElementById('loadMoreBtn');
loadMoreBtn.onclick = () => {
  loadedCount += batchSize;
  render();
};

// â”€â”€ paged & lazy render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function render() {
  const { Contents=[] } = await s3.send(new ListObjectsV2Command({ Bucket:BUCKET }));

  async function mapWithLimit(inputs, fn, limit=5) {
    const ret = [];
    let i = 0;
    async function worker() {
      while (i < inputs.length) {
        const idx = i++;
        ret[idx] = await fn(inputs[idx]);
      }
    }
    await Promise.all(Array(limit).fill().map(worker));
    return ret;
  }
  let page = Contents.slice(0, loadedCount);
  if (page.length === 0) {
    panelAll.innerHTML = panelMine.innerHTML = "<p>No uploads yet</p>";
    return;
  }
  // sort by *chosenDate* later, so first build an array with dates
  const withDates = await mapWithLimit(page, async ({Key,LastModified})=>{ 


    return { Key, LastModified, takenDate: await getExifDate(Key, LastModified)  };
  });

  // 3) Now sort by our chosenDate (newestâ†’oldest)
  withDates.sort((a, b) => b.takenDate - a.takenDate);

  console.log("withDates", withDates);

  // Now render in that order
  const mySet = mine();
  panelAll.innerHTML = panelMine.innerHTML = "";

  for (const { Key, takenDate } of withDates) {
    buildFigure(Key, takenDate, mySet);
  }

  loadMoreBtn.style.display = (loadedCount < Contents.length) ? 'inline-block' : 'none';
}


/* ---------- helpers -------------------------------------------------- */
// add a data-attribute that we can sort on
function tagWithTaken(fig, date) {
  fig.dataset.taken = String(date.getTime());   // newest â†’ largest number
}

// (re)sort all children in a panel by that attribute (DESC)
function sortPanel(panel) {
  [...panel.children]                       // live HTMLCollection â†’ array
    .sort((a, b) => Number(b.dataset.taken) - Number(a.dataset.taken))
    .forEach(el => panel.appendChild(el));  // re-append in correct order
}

// quickly wire clone â†’ delete handler
function rewireDelete(origFig, cloneFig) {
  const o = origFig.querySelector('.del');
  const c = cloneFig.querySelector('.del');
  if (o && c) c.onclick = o.onclick;
}

async function appendNew(keys) {
  const me = mine();

  for (const Key of keys) {
    // head + EXIF â†’ takenDate
    const head      = await s3.send(new HeadObjectCommand({ Bucket: BUCKET, Key }));
    const ms        = head.Metadata?.taken ? +head.Metadata.taken : Date.now();
    const takenDate = await getExifDate(Key, ms);

    /* build but DONâ€™T append yet */
    const fig = await buildFigure(Key, takenDate, me);

    loadedCount++;              // keep paging logic happy
  }

  /* finally: re-sort both panels so the new items land in place */
  sortPanel(panelAll);
  sortPanel(panelMine);

  /* update "Load more" visibility */
  const { Contents = [] } = await s3.send(new ListObjectsV2Command({ Bucket: BUCKET }));
  loadMoreBtn.style.display = loadedCount < Contents.length ? 'inline-block' : 'none';
}

async function getExifDate(Key, LastModified) {
  const url = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(Key)}`;
  let exif = {};
  try {
    exif = await parse(url, ["DateTimeOriginal"]) || {};
  } catch (err) {
    console.warn("EXIF parse failed for", url, err);
  }
  const origDate = exif.DateTimeOriginal;
  const origMs   = origDate instanceof Date ? origDate.getTime() : NaN;
  const modMs    = new Date(LastModified).getTime();

  return new Date(origMs || modMs);
}

async function buildFigure(Key, takenDate, mySet) {
    const url        = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(Key)}`;
    const isMine     = mySet.has(Key);
    const isVideo    = /\.(mp4|mov|webm)$/i.test(Key);
    const timePart = takenDate.toLocaleTimeString("en-US", {
      hour:   "2-digit",
      minute: "2-digit",
      hour12: false
    });
    const datePart = takenDate.toLocaleDateString("en-US", {
      month: "short",
      day:   "2-digit",
      year:  "numeric"
    });
    const tsReadable = `${timePart}, ${datePart}`;

    // build the figure
    const fig = document.createElement('figure');
    tagWithTaken(fig, takenDate);
    fig.style.cursor = 'pointer';
    fig.onclick = () => openOverlay(url, isVideo, tsReadable, Key.split('/').pop());

    // thumbnail or video placeholder
    if (isVideo) {
      const v = document.createElement('video');
      v.muted = true; v.controls = false; v.preload = 'none';
      v.dataset.src = url;
      fig.appendChild(v);
      io.observe(v);

      // add video icon
      const icon = document.createElement('img');
      icon.src   = 'https://img.icons8.com/fluency-systems-regular/48/video.png';
      icon.alt   = 'video';
      icon.className = 'video-icon';
      fig.appendChild(icon);
    } else {
      const img = document.createElement('img');
      img.loading   = 'lazy';
      img.dataset.src = url;
      fig.appendChild(img);
      io.observe(img);
    }

    // delete button (only on â€œmineâ€)
    if (isMine) {
      const del = document.createElement('button');
      del.className   = 'del';
      del.textContent = 'ğŸ—‘';
      del.onclick = async (e) => {
        e.stopPropagation();       // â† prevent openOverlay
        await s3.send(new DeleteObjectCommand({ Bucket:BUCKET, Key }));
        render();
      };
      fig.appendChild(del);
    }

    // always add to â€œAllâ€
    panelAll.appendChild(fig);

    // if itâ€™s mine, clone *and* re-attach handlers for â€œMy Uploadsâ€
    if (isMine) {
      // Clone the figure for the â€œMy Uploadsâ€ pane
      const clone = fig.cloneNode(true);

      // 1) Re-attach lazy-load observer to the cloned thumb
      const thumb = clone.querySelector('img, video');
      if (thumb) io.observe(thumb);

      // 2) Re-bind the click to openOverlay
      clone.onclick = fig.onclick;

      // 3) Swap out the delete buttonâ€™s handler to just open (no delete)
      const origDel  = fig .querySelector('.del');   // original delete handler
      const cloneDel = clone.querySelector('.del');  // delete in My Uploads
      if (origDel && cloneDel) {
        cloneDel.onclick = origDel.onclick;          // give it *the same* handler
      }

      panelMine.appendChild(clone);
    }

  return fig;
}



// initial render
render();
</script>
</body>
</html>
